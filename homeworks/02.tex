\documentclass{homework}

\title{02}
\author{Taaniel Kraavi}
\date{\DTMdate{2025-10-25}}

\usepackage{crysymb}
\usepackage{fancyvrb}
\fvset{listparameters=\setlength{\topsep}{0pt}\setlength{\partopsep}{0pt}}

\begin{document}
\maketitle

\textbf{Reminders}

\begin{itemize}
  \item Include in your report approximately how long the homework took for you.
  \item I will give you feedback on GitLab and Discord.
  Check them after receiving your (preliminary) grade.
  \item Read through task descriptions carefully.
  \item You may request deadline extensions until 22.10.25 23:59 EEST.
  \item You can submit up to one week after the deadline with a 50\% point penalty.
  0 afterwards.
  \item Grace clause:
  \begin{itemize}
    \item If you submit your assignment by the deadline, you have the opportunity to fix (some) mistakes I point out to gain back up to half of the lost points.
    \item You cannot get any points back for a task that is entirely missing or broken, e.g. code that does not run at all or does nothing.
    If your code does not pass the assertions/test script (if available), include that info in your report.
    Otherwise I will consider your code to be broken, i.e. no grace.
    Test your code!
    \item The grace clause does not apply if you requested an extension or missed the original deadline.
  \end{itemize}
  \item You may share hints with each-other, but no answers/code.
  Ask questions in the server if they could be useful for everyone.
  \item You may---and I encourage you to---ask me questions (preferably during practices).
  \item You may use AI as help, but not to solve the tasks themselves.
  \begin{itemize}
    \item Acceptable: e.g. checking your understanding, asking how to loop in Python
    \item Not acceptable: e.g. generating any code logic or cryptographic operations
    \item If you use AI in any form, include in your report what you used it for
    \item I recommend that you ask in the server/me instead of using AI
  \end{itemize}
  \item If I catch you plagiarising, copying, or using AI for theory answers or code logic, I will report you to the faculty and fail you for the course.
  \begin{itemize}
    \item If during the midterm/exam you completely fumble stuff that you got points for in homework tasks, you will have to orally explain why it is so.
    \item If you do not convince me of homework authorship, I will report you for cheating and fail you.
  \end{itemize}
\end{itemize}

\newpage

\begin{center}
  Theory tasks
\end{center}

\textbf{Additional instructions}

\begin{itemize}
  \item Call the file \texttt{theory.md} and include it in the \texttt{hw2} folder root.
  \item Store the picture files included in your report in the \texttt{hw2/images} folder.
  \item \textbf{Please do not use AI for the theoretical part!}
  Challenge your understanding and search for additional written materials in case the lecture+provided materials are not enough.
  Critical thinking is a skill: use it or lose it.
\end{itemize}

\begin{task}{ECIES}
  The Elliptic Curve Integrated Encryption Scheme (ECIES) is a hybrid cryptosystem framework: it combines a \emph{key encapsulation mechanism} (KEM) with a \emph{data encapsulation mechanism} (DEM) that is also \emph{authenticated}.
  Read through \href{https://cryptobook.nakov.com/asymmetric-key-ciphers/ecies-public-key-encryption}{\textit{this brief overview}} on ECIES and study the diagram.

  Answer the following:
  \begin{itemize}
    \item Why is ECIES suitable for non-interactive use cases?
    You can interpret \enquote{non-interactive} as Alice putting messages in Bob's letterbox rather than telling him the info in a phone call.
    \item Is ECIES closest to static-static, static-ephemeral, or ephemeral-ephemeral DH?
    \item Why does ECIES not offer PFS?
  \end{itemize}

  If you used additional sources, e.g. blog posts or CSE forums, include all used (helpful) links in the submission.

  What is the security level (in bits):
  \begin{itemize}
    \item against confidentiality attacks by a classical adversary, when the P-384 curve is used with AES-128?
    \item against confidentiality attacks by a quantum adversary, when the P-384 curve is used with AES-256?
  \end{itemize}

  When using AES-GCM as the authenticated DEM, after how many bytes of plaintext should Alice rekey, i.e. derive a new symmetric key from a new ECIES execution?
  Provide a source and a one/two sentence explanation.

  \iffalse
  As a rough overview, the following can be parametrised:
  \begin{itemize}
    \item the key derivation function (KDF), e.g. KDF2;
    \item the scheme for authenticating the encryption, e.g. HMAC-SHA-512;
    \item the symmetric encryption scheme, e.g. AES-256-CBC;
  \end{itemize}
  on top of different elliptic curve domain parameters.
  Some implementations even allow to change the key-agreement protocol (variations of DH).
  Combinations are also possible.
  For example, when using XChaCha20-Poly1305, a separate message-authentication scheme is no longer needed.
  \fi

  \iffalse
  Standards and implementations limit the allowed values for each of these parameters, which helps against misuse (e.g. picking weak options) but complicates interoperability.
  For example, no implementation can comply with all ECIES-defining standards.
  Furthermore, not all options and/or combinations provide equivalent security.
  Picking `strong' parameters while maintaining interoperability is therefore quite tricky. 

  For this task, find three standards where ECIES is defined.
  Then, highlight (preferably in a table) which parameters/algorithms are supported by all three standards (if any).
  \fi
\end{task}

\begin{task}{Password switcheroo}
  Oh no, you mistakenly encrypted your newly generated secret key with a really weak password (or even worse, you did not password protect it).
  Write down the OpenSSL command that you would use to change the password of your asymmetric secret key.

  If you want to check whether your command works, I have uploaded to Moodle the encrypted RSA private key file \texttt{demokey.pem} that is encrypted with the password \texttt{changeme}.
\end{task}

\begin{task}{ROCA}
  Read \href{https://crocs.fi.muni.cz/public/papers/rsa_ccs17}{\emph{this blog post}} by the researchers who discovered ROCA.
  More than 750 000 Estonian ID cards were impacted by this vulnerability.

  Summarise the discovery (what, why, how to fix) in no more than five sentences.
  Then succinctly answer the following:
  \begin{itemize}
    \item Did the researchers completely break 2048-bit RSA?
    \item Are ECC keys generated on the affected chips vulnerable?
    \item How can you detect if your keys are vulnerable?
    \item What is the worst-case price for factorising a 2048-bit impacted key?
    \item Name three mitigation strategies if your hardware is impacted.
  \end{itemize}
\end{task}

\begin{task}{Common attacks against RSA}
  Do some digging, then name a technique (with a source) for cracking RSA for each of the following:
  \begin{itemize}
    \item $p$ and $q$ are very close,
    \item the modulus $n$ is re-used with different private keys,
    \item the private exponent is small,
    \item the public exponent is small and OAEP is not used.
  \end{itemize}

  Give three examples why OAEP padding is important.
\end{task}

\begin{task}{Leaky ElGamal}
  Recall that for some secret $x\getsu\ZZ_q$ and generator $g$, the ElGamal public key is $\PK\gets g^x$.
  Encryption is then carried out with:
  \[
    r \getsu \ZZ_q, \ENC_\PK(m; r) = \bigl(g^r, m \cdot \PK^r\bigr) = (u, v) = c
  \]
  where $r$ is the randomness which makes ElGamal a probabilistic encryption scheme.

  Suppose now that $r$ is leaked, meaning that you know the $r$ used during encryption.
  Are you then able to recover $m$ from $c$ without the secret key?
  If yes, how so?

  Can you also decrypt other messages (without gaining access to new values of $r$)?
\end{task}

\newpage
\setcounter{task}{0}

\begin{center}
  Practical tasks
\end{center}

\textbf{Additional instructions}

\begin{itemize}
  \item I must be able to run your program with Python 3.13 and OpenSSL v3.5.1\footnotemark{}.
  \footnotetext{You may use older versions of Python and OpenSSL as long as you do not use deprecated functionality.}
  \item Do not import any 3\textsuperscript{rd} party module\footnotemark{} not specified in the template files.
  \footnotetext{You may change \texttt{Crypto} to \texttt{Cryptodome} if needed.}
  You are free to import any built-in module.
  If you feel the need to import some other 3\textsuperscript{rd} party module, please check with me beforehand!
  \item Your program must not have any unhandled errors (print a message and exit with an error code without printing the trace) except for file-based errors, e.g. file read/write errors.
  \item Include the files in the \texttt{hw2} folder, do not commit your Python virtual env.
  \item Your Python files must have the same name as the template files but without the \texttt{template} suffix, e.g. \texttt{interop\_template.py} becomes \texttt{interop.py}.
  \item You may change everything in the template files as long as I can run your program with the CLI arguments specified in the templates.
  \iffalse
  \item \textbf{Check before you submit!}
  You have ways to check whether each of your 3 tasks is functionally correct.
  If
  \begin{enumerate}
    \item I cannot review your homework before the deadline, \emph{and}
    \item your homework does not pass the checks, \emph{and}
    \item you have not stated in your report that this is the case (and what did you try),
  \end{enumerate}
  you \emph{fail} the homework!
  \fi
  \item Your repo must contain at least the following files:
  \begin{Verbatim}
hw2/
├── theory.md
├── homomorphic.py
├── pow.py
└── ossl_rsa.py
  \end{Verbatim}
\begin{Verbatim}
  
\end{Verbatim}
\end{itemize}

\begin{task}{RSA interop}
  Homework template file: \texttt{ossl\_rsa\_template.py}

  Create a Python3 program that performs RSA-OAEP\footnote{\url{https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding}} encryption/decryption by calling OpenSSL.
  Recall from the lecture that OAEP padding is required for probabilistic encryption, and to prevent some subtle attacks.
  Make sure to use OAEP with the SHA256 hash function for padding derivation, since its default hash function SHA1 is deprecated\footnote{We will see the specifics of this during week 7, so treat it as a \enquote{black box} good practice for now.}.

  \newpage

  Your program must provide three separate tools:
  \begin{itemize}
    \item \texttt{genpkey} --- generate an RSA private key

    Your program must generate a $3072$-bit RSA private key with OpenSSL and export it into a file in PEM format.
    Your program \emph{must not} print the key-generation progress bar to the console.

    The private key must be password protected according to the following:
    \begin{itemize}
      \item The key derivation function for obtaining the encryption key must be PBKDF2, and the parameters must be:
      \begin{itemize}
        \item \texttt{HMAC-SHA512} for the PRF,
        \item an iteration count of $210000$ (OWASP recommendation).
      \end{itemize}
      \item The key must be encrypted with AES-256 in CBC mode and use the PKCS\#8 format.
      \item At no point should the private key be written unencrypted to the disk.
    \end{itemize}

    \begin{tcolorbox}[title=Note]
      New versions of OpenSSL (> 3.0) should use PKCS\#8 by default if you export an encrypted private key in PEM, but do not allow for the fine-grained control needed for this task.

      Hint: Can you find a tool in the OpenSSL documentation which allows more fine-grained control over PKCS\#8 encrypted private keys? 
    \end{tcolorbox}

    You can see what the expected private key structure looks like by dumping the ASN.1 structure of the example private key given on Moodle.

    Example invocation:
    \begin{Verbatim}
python3 ossl_rsa.py genpkey --out key.pem --pass secret
    \end{Verbatim}

    \item \texttt{pkey} --- public key derivation
    
    Your program must extract the public key from a private key and export it into a file in PEM format by using OpenSSL.

    Example invocation:
    \begin{Verbatim}
python3 ossl_rsa.py pkey --in key.pem \
    --out pub.pem --pass secret
    \end{Verbatim}

    \item \texttt{pkeyutl} --- file encryption and decryption
    
    Your program must output the encryption or decryption of the specified input file with the specified key to the specified output file using OpenSSL.

    Example invocation for encryption:
    \begin{Verbatim}
python3 ossl_rsa.py pkeyutl --encrypt \
    --inkey pub.pem --in message.txt --out data.enc
    \end{Verbatim}

    Example invocation for decryption:
    \begin{Verbatim}
python3 ossl_rsa.py pkeyutl \
    --inkey key.pem --in data.enc --out data.enc \
    --pass secret
    \end{Verbatim}
  \end{itemize}

  Make sure to handle errors by printing an informational message and exiting with an error code (\texttt{sys.exit(1)}) without printing the exception trace.
  Your program must not crash if missing parameters are provided, the wrong password is provided, OpenSSL fails, etc.
  Some error handling and hints are part of the template, but not all of it.

  All printed error messages must start with the string \enquote{Handled:}.

  You do not however have to (but you may) check for file I/O errors, i.e. you may assume that if you provide a filename, then that filename does exist or can be written to.

  \begin{tcolorbox}[title=Reminder]
    In practice, providing secrets (e.g. keys, passwords, etc.) directly on the CLI as an argument to a program is a terrible idea, since they typically get logged into your terminal history!
  \end{tcolorbox}

  You can check whether your code is functional with the script \texttt{ossl\_check.py}.
  This script does not test for error handling, so do not consider it as the definitive validator.
  I have not included the error handling checks in this script since it would give away the edge cases and I want you to think about them yourself.
  The script requires the following python3 modules: \texttt{pycryptodome}, \texttt{pyasn1}, \texttt{pyasn1-modules}.

  \iffalse
  \begin{tcolorbox}[title=Reading comprehension]
    Beware!
    If you submit a homework which:
    \begin{itemize}
      \item does not pass the test script \textbf{and}
      \item do not mention this in your report \textbf{and}
      \item do not describe in your report what you tried and what problems you still have,
    \end{itemize}
    I will consider your homework as unsubmitted for grading.
    If the deadline hits with your homework in this state, you fail the homework.
    \tcblower
    Motivation: in cryptography (and cybersecurity in general), paying close attention to details is crucial.
    If you cannot be bothered to pay attention and check whether things work, you should not work in cryptography.
  \end{tcolorbox}
  \fi
\end{task}

\begin{task}{256-bit RSA}
  The following data represents a 256-bit RSA public key.
  \begin{Verbatim}
-----BEGIN PUBLIC KEY-----
MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAITRpRf+PNWruknCVkz+bCvD+09P84Gf
CBSO7oyM87qHAgMBAAE=
-----END PUBLIC KEY-----
  \end{Verbatim}
  Find the two RSA primes used for obtaining this key and include them in your report in written form as base10 integers.
  Show how you obtained the primes (preferably with a screenshot of reasonable resolution) and include any applicable links.
\end{task}

\newpage

\begin{task}{Nifty homomorphism}
  Homework template file: \texttt{homomorphic\_template.py}

  The template contains a hard-coded ElGamal public key and an ElGamal encryption function (\texttt{pk.encrypt()}).
  Recall that an ElGamal ciphertext $c$ is comprised of two parts:
  \[
    c = (u, v) = \bigl(g^r, m\cdot\PK^r\bigr).
  \]

  The legendary cryptographer Mr. Cry has developed the following authentication protocol:
  \begin{itemize}
    \item Authorised users know the secret authentication number.
    \item To gain access to the server, users encrypt this number (with ElGamal) to obtain the \emph{token}, submit the token to the server, and the server decrypts it.
    If the decrypted number corresponds to the authentication number, the user is granted access.
    \item To avoid authentication token re-use, the server remembers all previously used tokens (encrypted numbers).
    If you submit an already used token, the server will deny you access.
    \item To mitigate \enquote{double-submission} (you submit the same token twice e.g. due to bad latency), the server displays the previously used token to the user.
  \end{itemize}

  Your goal is to forge a token and thus gain access.

  Your program must accept an ElGamal ciphertext (the token) as two integers on the command line\footnote{See the parsed arguments in the template.}, and print the token into the console in the following manner\footnote{This is taken care of by the template.}: $u$ as a base10 integer and $v$ as a base10 integer on the next line.
  E.g.
  \begin{Verbatim}
python3 homomorphic.py 157928...613543 296738...721947
1058509285116...9238765983746
6819523011802...1625917583932
  \end{Verbatim}
  without the dots in the middle.
  
  Your task succeeds if:
  \begin{itemize}
    \item $\DEC_\SK\bigl((u_\mathit{challenge}, v_\mathit{challenge})\bigr) = \DEC_\SK\bigl((u_\mathit{you}, v_\mathit{you})\bigr)$, and
    \item $(u_\mathit{challenge}, v_\mathit{challenge}) \neq (u_\mathit{you}, v_\mathit{you})$.
  \end{itemize}

  You can get a test token from the Discord bot and submit your answer to it to validate your solution.
  Note that the Discord bot uses a different public key than the one provided in the template.
  Please use the template's public key in your submission.
\end{task}

\newpage

\begin{task}{Proof of work}
  Homework template file: \texttt{pow\_template.py}

  The template contains the functions \texttt{l0\_bits} and \texttt{bruteforce} that you must implement yourself.
  Do not edit the \texttt{main} function, except to set the seed to your student username (\enquote{takraa}) for me.

  Include in your submission the printed output from the \texttt{main} function!

  The \texttt{l0\_bits} function should count the number of leading 0 bits in the byte string and return it.
  Since this is part of the code logic, you may not ask some AI to generate it for you.

  The \texttt{bruteforce} function should iteratively generate 8-byte nonces until the hash value of \texttt{SHA256(SHA256(seed||nonce))}
  starts with 25 zero-bits (the challenge \enquote{difficulty}). That is, you try for nonces:
  \begin{enumerate}
    \item \texttt{0x0000000000000000}
    \item \texttt{0x0000000000000001}
    \item \texttt{0x0000000000000002}
    \item \dots
  \end{enumerate}

  For example, for the seed \texttt{takraa}, the smallest integer nonce that produces the desired hash is $86197437$.
  Indeed, the hex value of this integer is \texttt{0x00000000052344bd}, and
   \begin{Verbatim}
SHA256(SHA256(b"takraa\x00\x00\x00\x00\x05\x23\x44\xbd"))
  \end{Verbatim}
  yields the hash value
  \begin{Verbatim}
00000060c45f26ecd9d97c05571088b77ccaed193f5723b7fd526982b5b0eebc
  \end{Verbatim}
  the first 25 bits of which are \enquote{0}.
\end{task}

This is a simple variant of the \href{https://en.wikipedia.org/wiki/Hashcash}{\textit{Hashcash}} proof-of-work system, which is used for example in Bitcoin mining.
You may (but need not) read more about Bitcoin's proof of work \href{https://en.bitcoin.it/wiki/Proof_of_work}{\textit{here}}.

The core idea behind a proof of work (PoW) is to prove that you have expended some amount of computational effort.
In essence, it is a puzzle that is computationally costly to solve, but the solution of which is easy to verify (similarly to the desired asymmetry in public-key cryptography).

I might ask in the exam what the point of a proof of work is, and what the idea behind Hashcash was (how it was meant to reduce email spam).

\end{document}
